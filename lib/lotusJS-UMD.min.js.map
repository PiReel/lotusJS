{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///lotusJS-UMD.min.js","webpack:///webpack/bootstrap b739364b0d893a98fb5a?e7cd","webpack:///./src/context/CommandMap.ts?45e2","webpack:///./src/context/Context.ts?7eb9","webpack:///./src/context/Injector.ts?d857","webpack:///./src/index.ts?eac3"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","CommandMap","context","eventFunctionMap","instanceMap","addCommand","eventType","handler","functionName","useSingleton","undefined","hasCommandMap","push","eventDispatcher","canListen","addEventListener","hasCommand","mapArray","itemIndex","length","item","removeCommand","shift","pop","head","slice","tail","concat","removeEventListener","removeAllCommands","removeAllEventListeners","routeEventToCommand","event","type","instance","Context","config","params","Injector","objectMap","mapObject","key","constructor","mapSingletonInstance","inject","Error","__export"],"mappings":"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","file":"lotusJS-UMD.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Lotus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Lotus\"] = factory();\n\telse\n\t\troot[\"Lotus\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Lotus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Lotus\"] = factory();\n\telse\n\t\troot[\"Lotus\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CommandMap = (function () {\r\n    function CommandMap(context) {\r\n        //Note: this could be improved by creating read only accessor methods for instanceMap and eventFunctionMap\r\n        this.eventFunctionMap = {};\r\n        this.instanceMap = {};\r\n        this.context = context;\r\n    }\r\n    CommandMap.prototype.addCommand = function (eventType, handler, functionName, useSingleton) {\r\n        if (functionName === void 0) { functionName = 'execute'; }\r\n        if (useSingleton === void 0) { useSingleton = false; }\r\n        if (this.eventFunctionMap[eventType] === null || this.eventFunctionMap[eventType] === undefined) {\r\n            this.eventFunctionMap[eventType] = [];\r\n        }\r\n        if (this.hasCommandMap(eventType, handler, functionName)) {\r\n            return; //don't add the handler/function twice\r\n        }\r\n        this.eventFunctionMap[eventType].push({ eventType: eventType, handler: handler, functionName: functionName, useSingleton: useSingleton });\r\n        if (useSingleton) {\r\n            if (this.instanceMap[eventType] === null || this.instanceMap[eventType] === undefined) {\r\n                this.instanceMap[eventType] = {};\r\n            }\r\n            if (this.instanceMap[eventType][handler] === null || this.instanceMap[eventType][handler] === undefined) {\r\n                this.instanceMap[eventType][handler] = new handler(this.context);\r\n            }\r\n        }\r\n        if (!this.context.eventDispatcher.canListen(eventType, this, 'routeEventToCommand')) {\r\n            this.context.eventDispatcher.addEventListener(eventType, this, 'routeEventToCommand');\r\n        }\r\n    };\r\n    CommandMap.prototype.hasCommandMap = function (eventType, handler, functionName) {\r\n        var hasCommand = false;\r\n        if (this.eventFunctionMap[eventType] !== null && this.eventFunctionMap[eventType] !== undefined) {\r\n            var mapArray = this.eventFunctionMap[eventType];\r\n            for (var itemIndex = 0; itemIndex < mapArray.length; itemIndex++) {\r\n                var item = mapArray[itemIndex];\r\n                if (item.handler == handler && item.functionName == functionName) {\r\n                    hasCommand = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return hasCommand;\r\n    };\r\n    CommandMap.prototype.removeCommand = function (eventType, handler) {\r\n        if (this.eventFunctionMap[eventType] !== null && this.eventFunctionMap[eventType] !== undefined) {\r\n            var mapArray = this.eventFunctionMap[eventType];\r\n            for (var itemIndex = mapArray.length - 1; itemIndex >= 0; itemIndex--) {\r\n                var item = mapArray[itemIndex];\r\n                if (item.handler == handler) {\r\n                    //remove the item form the array\r\n                    switch (itemIndex) {\r\n                        case 0:\r\n                            mapArray.shift();\r\n                            break;\r\n                        case mapArray.length - 1:\r\n                            mapArray.pop();\r\n                            break;\r\n                        default:\r\n                            var head = mapArray.slice(0, itemIndex);\r\n                            var tail = mapArray.slice(itemIndex + 1);\r\n                            mapArray = head.concat(tail);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (this.eventFunctionMap[eventType].length <= 0) {\r\n                this.context.eventDispatcher.removeEventListener(eventType, this, 'routeEventToCommand');\r\n                delete this.eventFunctionMap[eventType];\r\n            }\r\n        }\r\n    };\r\n    CommandMap.prototype.removeAllCommands = function () {\r\n        this.eventFunctionMap = {};\r\n        this.instanceMap = {};\r\n        this.context.eventDispatcher.removeAllEventListeners(this);\r\n    };\r\n    CommandMap.prototype.routeEventToCommand = function (event) {\r\n        if (this.eventFunctionMap[event.type] !== null && this.eventFunctionMap[event.type] !== undefined) {\r\n            var mapArray = this.eventFunctionMap[event.type];\r\n            for (var itemIndex = 0; itemIndex < mapArray.length; itemIndex++) {\r\n                var item = mapArray[itemIndex];\r\n                if (item.useSingleton) {\r\n                    this.instanceMap[item.event.type][item.handler][item.functionName]();\r\n                }\r\n                else {\r\n                    var instance;\r\n                    if (typeof item.handler === 'object') {\r\n                        instance = item.handler;\r\n                    }\r\n                    else {\r\n                        //IMPORTANT: only constructor function will get the context! This is by design as it's assumed preconstructed objects have all required dependencies\r\n                        instance = new item.handler(this.context);\r\n                    }\r\n                    instance[item.functionName](event);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return CommandMap;\r\n}());\r\nexports.CommandMap = CommandMap;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Created by dsmiley on 7/24/17.\r\n */\r\nvar Context = (function () {\r\n    function Context(config, params) {\r\n    }\r\n    return Context;\r\n}());\r\nexports.Context = Context;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Injector = (function () {\r\n    function Injector(context) {\r\n        this.context = context;\r\n        this.objectMap = {};\r\n    }\r\n    Injector.prototype.mapObject = function (key, constructor, useSingleton) {\r\n        if (useSingleton === void 0) { useSingleton = false; }\r\n        //instantiate singleton instance upon request is more efficient\r\n        this.objectMap[key] = { constructor: constructor, useSingleton: useSingleton, instance: null };\r\n    };\r\n    Injector.prototype.mapSingletonInstance = function (key, instance) {\r\n        //map injector as sigleton using the supplied instance\r\n        //this method is very useful for mapping objects that are themselves singletons and may have already been constructed\r\n        //prime example is the model wich generally is constructed before injections are defined\r\n        this.objectMap[key] = { constructor: null, useSingleton: true, instance: instance };\r\n    };\r\n    Injector.prototype.inject = function (key) {\r\n        if (this.objectMap[key] !== null && this.objectMap[key] !== undefined) {\r\n            if (this.objectMap[key].useSingleton) {\r\n                if (this.objectMap[key].instance === null) {\r\n                    this.objectMap[key].instance = new this.objectMap[key].constructor();\r\n                }\r\n                return this.objectMap[key].instance;\r\n            }\r\n            else {\r\n                return new this.objectMap[key].constructor();\r\n            }\r\n        }\r\n        throw new Error('Lotus.Injector.prototype.getObject: could not find object for key: ' + key);\r\n    };\r\n    return Injector;\r\n}());\r\nexports.Injector = Injector;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(1));\r\n__export(__webpack_require__(2));\r\n__export(__webpack_require__(0));\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// lotusJS-UMD.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b739364b0d893a98fb5a","/**\n * Created by dsmiley on 7/24/17.\n */\nimport {IContext} from './IContext';\nimport {ICommandMap} from './ICommandMap';\nimport {IEvent} from '../../node_modules/lavenderjs/lib';\n\nexport class CommandMap implements ICommandMap{\n    public eventFunctionMap:Object;\n    public instanceMap:Object;\n    public context:IContext;\n\n    constructor(context:IContext){\n        //Note: this could be improved by creating read only accessor methods for instanceMap and eventFunctionMap\n        this.eventFunctionMap = {};\n        this.instanceMap = {};\n        this.context = context;\n    }\n\n    public addCommand(eventType:string, handler:any, functionName:string='execute', useSingleton:boolean=false){\n        if( this.eventFunctionMap[eventType] === null || this.eventFunctionMap[eventType] === undefined ){\n            this.eventFunctionMap[eventType] = [];\n        }\n\n        if( this.hasCommandMap( eventType, handler, functionName ) ){\n            return;//don't add the handler/function twice\n        }\n\n        this.eventFunctionMap[eventType].push({eventType:eventType, handler:handler, functionName:functionName, useSingleton:useSingleton});\n\n        if( useSingleton ){\n            if( this.instanceMap[eventType] === null ||  this.instanceMap[eventType] === undefined ){\n                this.instanceMap[eventType] = {};\n            }\n            if( this.instanceMap[eventType][handler] === null ||  this.instanceMap[eventType][handler] === undefined ){\n                this.instanceMap[eventType][handler] = new handler(this.context);\n            }\n        }\n        if( !this.context.eventDispatcher.canListen(eventType, this, 'routeEventToCommand') ){\n            this.context.eventDispatcher.addEventListener(eventType, this, 'routeEventToCommand');\n        }\n    }\n\n    public hasCommandMap(eventType:string, handler:Object, functionName:string){\n        var hasCommand = false;\n        if( this.eventFunctionMap[eventType] !== null && this.eventFunctionMap[eventType] !== undefined ){\n            var mapArray = this.eventFunctionMap[eventType];\n            for( var itemIndex = 0; itemIndex < mapArray.length; itemIndex++){\n                var item = mapArray[ itemIndex ];\n                if( item.handler == handler && item.functionName == functionName ){\n                    hasCommand = true;\n                    break;\n                }\n            }\n        }\n        return hasCommand;\n    }\n\n    public removeCommand(eventType:string, handler:Object){\n        if( this.eventFunctionMap[eventType] !== null && this.eventFunctionMap[eventType] !== undefined ){\n            var mapArray = this.eventFunctionMap[eventType];\n            for( var itemIndex = mapArray.length - 1; itemIndex >= 0; itemIndex--){\n                var item = mapArray[ itemIndex ];\n                if( item.handler == handler ){\n                    //remove the item form the array\n                    switch (itemIndex) {\n                        case 0:\n                            mapArray.shift();\n                            break;\n                        case mapArray.length - 1:\n                            mapArray.pop();\n                            break;\n                        default:\n                            var head = mapArray.slice(0, itemIndex);\n                            var tail = mapArray.slice(itemIndex + 1);\n                            mapArray = head.concat(tail);\n                            break;\n                    }\n                }\n            }\n            if( this.eventFunctionMap[eventType].length <= 0 ){\n                this.context.eventDispatcher.removeEventListener(eventType, this, 'routeEventToCommand');\n                delete this.eventFunctionMap[eventType];\n            }\n        }\n    }\n\n    public removeAllCommands(){\n        this.eventFunctionMap = {};\n        this.instanceMap = {};\n        this.context.eventDispatcher.removeAllEventListeners(this);\n    }\n\n    public routeEventToCommand(event:IEvent){\n        if( this.eventFunctionMap[event.type] !== null && this.eventFunctionMap[event.type] !== undefined ){\n            var mapArray = this.eventFunctionMap[event.type];\n            for( var itemIndex = 0; itemIndex < mapArray.length; itemIndex++){\n                var item = mapArray[ itemIndex ];\n                if( item.useSingleton ){\n                    this.instanceMap[item.event.type][item.handler][item.functionName]();\n                }else{\n                    var instance;\n                    if( typeof item.handler === 'object' ){\n                        instance = item.handler;\n                    }else{\n                        //IMPORTANT: only constructor function will get the context! This is by design as it's assumed preconstructed objects have all required dependencies\n                        instance = new item.handler(this.context);\n                    }\n                    instance[item.functionName](event);\n                }\n            }\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/context/CommandMap.ts","/**\n * Created by dsmiley on 7/24/17.\n */\nexport class Context{\n    public config:Object;\n    public eventDispatcher;\n    \n    constructor(config:Object, params:Object){\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/context/Context.ts","/**\n * Created by dsmiley on 7/24/17.\n */\nimport {IContext} from './IContext';\nimport {IInjector} from './IInjector';\n\nexport class Injector implements IInjector{\n    public context:IContext;\n    public objectMap:Object;\n\n    constructor(context:IContext){\n        this.context = context;\n        this.objectMap = {};\n    }\n\n    public mapObject(key:string, constructor:Function, useSingleton:boolean=false){\n        //instantiate singleton instance upon request is more efficient\n        this.objectMap[key] = {constructor:constructor, useSingleton:useSingleton, instance:null};\n    }\n\n    public mapSingletonInstance(key:string, instance:any){\n        //map injector as sigleton using the supplied instance\n        //this method is very useful for mapping objects that are themselves singletons and may have already been constructed\n        //prime example is the model wich generally is constructed before injections are defined\n        this.objectMap[key] = {constructor:null, useSingleton:true, instance:instance};\n    }\n\n    public inject(key:string):Object{\n        if( this.objectMap[key] !== null && this.objectMap[key] !== undefined ){\n            if( this.objectMap[key].useSingleton ){\n                if( this.objectMap[key].instance === null ){\n                    this.objectMap[key].instance = new this.objectMap[key].constructor();\n                }\n                return this.objectMap[key].instance;\n            }else{\n                return new this.objectMap[key].constructor();\n            }\n        }\n        throw new Error('Lotus.Injector.prototype.getObject: could not find object for key: ' + key);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/context/Injector.ts","/**\n * Created by dsmiley on 7/24/17.\n */\nexport * from './context/IContext';\nexport * from './context/Context';\nexport * from './context/IInjector';\nexport * from './context/Injector';\nexport * from './context/ICommandMap';\nexport * from './context/CommandMap';\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts"],"sourceRoot":""}